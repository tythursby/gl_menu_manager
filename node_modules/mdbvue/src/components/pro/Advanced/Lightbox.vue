<template>
  <transition name="fade">
    <div v-if="visible" class="img-swiper box" @click.self="closeDialog">
        <div class="img-wrapper transition" :style="imgStyle">
          <!-- START: Imgs -->
          <img
            class="img"
            :class="touch.detected && 'touch-img'"
            :src="currentImg.img"
            ref="img"
            :alt="currentImg.caption"
            draggable="false"
            @mousedown.stop="handleMouseDown($event)"
            @mouseup.stop="handleMouseUp($event)"
            @mousemove.stop="handleMouseMove($event)"
            v-on="touch.detected ? {touchstart: handleTouchStart, touchmove: handleTouchMove, touchend: handleTouchEnd} : null"
          />
          <figcaption class="caption">{{currentImg.caption}}</figcaption>
          <!-- END: Imgs -->
        </div>

      <!-- START: btns mobile-->
      <div class="btns" v-if="touch.detected">
        <div
          v-if="imgList.length !== 1"
          class="btn__prev"
          :class="{disable: imgIndex === 0}"
        >
          <mdb-btn
            tag="a"
            color="grey"
            size="lg"
            floating
            class="touch"
            icon="chevron-left"
            @click="prev"
          ></mdb-btn>
        </div>
        <div
          v-if="imgList.length !== 1"
          class="btn__next"
          :class="{disable: imgIndex === imgList.length - 1}"
        >
          <mdb-btn
            tag="a"
            color="grey"
            size="lg"
            floating
            class="touch"
            icon="chevron-right"
            @click="next"
          ></mdb-btn>
        </div>
      </div>
      <!-- END: btns mobile-->

      <!-- START: btns -->
      <div class="btns" v-else>
        <div
          v-if="imgList.length !== 1"
          class="btn__prev"
          :class="{disable: imgIndex === 0}"
          @click="prev"
        >
          <button
            class="pswp__button pswp__button--arrow--left"
            title="Previous (arrow left)"
            :class="{touch: touch.detected}"
          >
            <use xlink:href="#icon-prev"></use>
          </button>
        </div>
        <div
          v-if="imgList.length !== 1"
          class="btn__next"
          :class="{disable: imgIndex === imgList.length - 1}"
          @click="next"
        >
          <button
            class="pswp__button pswp__button--arrow--right"
            title="Next (arrow right)"
            :class="{touch: touch.detected}"
          >
            <use xlink:href="#icon-next"></use>
          </button>
        </div>
        <div class="btn__close" @click="closeDialog">
          <button class="pswp__button pswp__button--close" title="Close (Esc)">
            <use xlink:href="#icon-close"></use>
          </button>
        </div>
        <div class="toolbar-btns">
          <div class="toolbar-btn toolbar-btn__zoomin" @click="zoomIn()">
            <button class="pswp__button pswp__button--zoom" title="Zoom in">
              <use xlink:href="#icon-zoomin"></use>
            </button>
          </div>
          <div class="toolbar-btn toolbar-btn__zoomout" @click="zoomOut()">
            <button class="pswp__button pswp__button--zoom lb-zoom-out" title="Zoom out">
              <use xlink:href="#icon-zoomout"></use>
            </button>
          </div>
        </div>
      </div>
      <!-- END: btns -->

      <!-- START: total -->
      <div v-if="imgList.length !== 1" class="pagination-total">{{ imgIndex + 1 }}/{{ imgTotal }}</div>
      <!-- END: total -->
    </div>
  </transition>
</template>

<script>
import { mdbIcon } from "../../Content/Fa";
import { mdbBtn } from "../../Components/Button";
const Lightbox = {
  name: "Lightbox",
  props: {
    imgs: {
      type: [Array, String]
    },
    captions: {
      type: [Array, String]
    },
    visible: {
      type: Boolean
    },
    index: {
      type: Number,
      default: 0
    }
  },
  components: {
    mdbIcon,
    mdbBtn
  },
  data() {
    return {
      scale: 1,
      rotateDeg: 0,
      imgIndex: 0,
      top: 0,
      left: 0,
      lastX: 0,
      lastY: 0,
      isDragging: false,
      movementX: 0,
      movementY: 0,
      touch: {
        detected: false,
        delta: 0,
        vectorLen: 0,
        zoom: 0,
        tap: {
          start: 0,
          end: 0
        },
        prevTap: {
          start: 0,
          end: 0
        }
      }
    };
  },
  methods: {
    checkBtn(btn) {
      if (btn === 0) return true;
      return false;
    },
    setViewParams() {
      const { width, height } = this.$refs.img.getBoundingClientRect();
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      this.movementX = width - windowWidth;
      this.movementY = height - windowHeight;
    },
    calculatePosition(e) {
      if (this.isDragging) {
        this.top = this.movementY > 0 ? Math.min(Math.max((this.top - this.lastY + e.clientY), -this.movementY/2), this.movementY/2): 0;
        this.left = this.movementX > 0 ? Math.min(Math.max((this.left - this.lastX + e.clientX), -this.movementX/2), this.movementX/2) : 0;
        this.lastY = e.clientY;
        this.lastX = e.clientX;
      }
    },
    handleMouseDown(e) {
      if (!this.checkBtn(e.button)) return;
      this.lastX = e.clientX;
      this.lastY = e.clientY;
      this.setViewParams();
      this.isDragging = true;
      e.target.style.cursor = "move";
    },
    handleMouseUp(e) {
      if (!this.checkBtn(e.button)) return;
      this.isDragging = false;
      e.target.style.cursor = "default";
      this.lastX = 0;
      this.lastY = 0;
    },
    handleMouseMove(e) {
      if (!this.checkBtn(e.button)) return;
      this.calculatePosition(e);
    },
    zoomIn(e) {
      const delta = this.touch.detected ? this.touch.zoom : 0.25;
      this.scale += delta;
    },
    zoomOut() {
      const delta = this.touch.detected ? this.touch.zoom : 0.25;
      this.scale = this.scale - delta > 1 ? this.scale - delta : 1;
      this.setViewParams();
      if (this.movementX <= 0) {
        this.left = 0;
      }
      if (this.movementY <= 0) {
        this.top = 0;
      }
    },
    rotate() {
      this.rotateDeg += 90;
    },
    next() {
      if (this.imgIndex === this.imgList.length - 1) return;
      this.reset();
      this.imgIndex += 1;
    },
    prev() {
      if (this.imgIndex === 0) return;
      this.reset();
      this.imgIndex -= 1;
    },
    reset() {
      this.scale = 1;
      this.top = 0;
      this.left = 0;
      this.rotateDeg = 0;
    },
    closeDialog() {
      if (!this.isDragging) {
        this.$emit("hide");
      }
    },
    init() {
      this.imgIndex = this.index;
      this.scale = 1;
      this.rotateDeg = 0;
      this.top = 0;
      this.left = 0;
    },
    onFirstTouch() {
      this.touch.detected = true;
      window.removeEventListener("touchstart", this.onFirstTouch, false);
    },
    handleTouchStart(e) {
      e.preventDefault();
      this.touch.tap.start = new Date().getTime();
      if (this.imgWidth > window.innerWidth) {
        this.lastX = e.touches[0].clientX;
        this.lastY = e.touches[0].clientY;
        this.setViewParams();
        this.isDragging = true;
        e.stopPropagation();
      }
    },
    handleTouchMove(e) {
      e.preventDefault();
      if (e.touches.length === 2) {
        const touches = Array.from(e.touches);
        const vector = Math.sqrt(
          Math.pow(touches[0].clientX - touches[1].clientX, 2) +
            Math.pow(touches[0].clientY - touches[1].clientY, 2)
        );
        this.touch.delta = vector - this.touch.vectorLen;
        this.touch.vectorLen = vector;
        this.touch.zoom = Math.abs(this.touch.vectorLen) / 320;

        if (this.touch.delta > 0) {
          this.zoomIn();
        } else {
          this.zoomOut();
        }
      }
      else if (e.touches.length === 1) {
        this.calculatePosition(e.touches[0]);
      }
      e.stopPropagation();
    },
    handleTouchEnd(e) {
      e.preventDefault();
      this.touch.tap.end = new Date().getTime();
      const currentTap = this.touch.tap.end - this.touch.tap.start;
      const previousTap = this.touch.prevTap.end - this.touch.prevTap.start;
      if (
        this.touch.tap.end - this.touch.prevTap.end < 600 &&
        currentTap < 100 &&
        previousTap < 100
      ) {
        if (this.scale === 1) {
          this.scale = 3;
        } else {
          this.scale = 1;
          this.top = 0;
          this.left = 0;
        }
      }
      this.touch.prevTap.start = this.touch.tap.start;
      this.touch.prevTap.end = this.touch.tap.end;

      this.isDragging = false;
      this.lastX = 0;
      this.lastY = 0;
    }
  },
  computed: {
    imgWidth() {
      return (
        window
          .getComputedStyle(this.$refs.img)
          .getPropertyValue("width")
          .match(/\d*/)
          .find(el => el) * this.scale
      );
    },
    imgList() {
      if (Object.prototype.toString.call(this.imgs) === "[object Array]") {
        return this.imgs;
      }
      return [this.imgs];
    },
    currentImg() {
      return this.imgList.map((img, i) => {
        const caption = this.captions ? this.captions[i] : '';
        return {img, index: i, caption };
      }).filter(img => img.index === this.imgIndex)
        .find(i => i);
    },
    imgTotal() {
      return this.imgList.length || 0;
    },
    imgStyle: {
      get() {
        return {
          transform: `translate(-50%, -50%)
            scale(${this.scale})
            rotate(-${this.rotateDeg}deg)`,
          top: `calc(50% + ${this.top}px)`,
          left: `calc(50% + ${this.left}px)`
        };
      }
    }
  },
  watch: {
    visible(visible) {
      if (visible === true) {
        this.init();
      }
    }
  },
  mounted() {
    window.addEventListener("touchstart", this.onFirstTouch, false);
    let self = this;
    window.onkeyup = function(e) {
      let key = e.keyCode ? e.keyCode : e.which;
      switch (key) {
        case 37:
          self.prev();
          break;
        case 39:
          self.next();
          break;
        case 38:
          self.zoomIn();
          break;
        case 40:
          self.zoomOut();
          break;
        case 27:
          self.closeDialog();
      }
    };
  }
};

export default Lightbox;
export { Lightbox as mdbLightbox };
</script>

<style scoped>

.icon {
  width: 1em;
  height: 1em;
  vertical-align: -0.15em;
  fill: currentColor;
  overflow: hidden;
}
.fade-enter-active,
.fade-leave-active {
  transition: all 0.3s ease;
}
.fade-enter,
.fade-leave-to {
  opacity: 0;
}
.img-swiper {
  position: relative;
}
.box {
  z-index: 9998;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: black;
}
.img-wrapper {
  margin: 0;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50% -50%);
  transform: scale(1);
  /* cursor: move; */
}
.img-wrapper.transition {
  transition: all 0.3s ease-in-out;
}
.img {
  max-width: 80vw;
  max-height: 80vh;
  vertical-align: middle;
  position: relative;
}

.btn__prev,
.btn__next,
.btn__close {
  cursor: pointer;
  position: absolute;
  font-size: 60px;
  color: #fff;
  opacity: 0.6;
  transition: 0.15s linear;
}
.btn__prev:hover,
.btn__next:hover,
.btn__close:hover {
  opacity: 1;
}
.btn__prev.disable:hover,
.btn__next.disable:hover,
.btn__prev.disable,
.btn__next.disable {
  cursor: default;
  opacity: 0.2;
}
.btn__next {
  top: 50%;
  right: 20px;
  font-size: 40px;
}
.btn__prev {
  top: 50%;
  left: 20px;
  font-size: 40px;
}
.btn__close {
  top: 10px;
  right: 10px;
  font-size: 40px;
}
.pagination-total {
  position: absolute;
  font-size: 16px;
  top: 16px;
  left: 16px;
  color: white;
  opacity: 0.75;
}
.toolbar-btns {
  user-select: none;
  position: absolute;
  top: 0;
  right: 50px;
  border-radius: 4px;
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
  padding: 6px;
}
.toolbar-btn {
  cursor: pointer;
  display: inline-block;
  padding: 3px;
}
.toolbar-btn .icon {
  width: 32px;
  height: 32px;
  fill: #fff;
}
.toolbar-btn:hover .icon {
  fill: #54b4ee;
}
.pswp__button--zoom {
  display: block;
}
.lb-zoom-out {
  background-position: -132px 0;
}
.lb-rotate-button {
  background: none;
}

.touch {
  position: relative;
  top: -36px;
}

@media screen and (min-height: 500px) and (max-width: 420px) {
  .touch {
    position: relative;
    top: 180px;
  }
  .touch-img {
    max-width: 100vw !important;
    max-height: 100vh !important;
  }
}

.caption {
  text-align: center;
  color: #ccc;
  font-size: 13px;
  padding-top: 15px;
  max-width: 500px;
  margin: auto;
}
</style>
